using System.Diagnostics;
using HidControl.Application.Abstractions;

namespace HidControlServer.Services;

/// <summary>
/// Supervises the external <c>Tools/WebRtcVideoPeer</c> helper process.
///
/// The helper establishes a WebRTC session for video-plane rooms and is responsible for media
/// publication (currently synthetic VP8 stream generated by the helper).
/// </summary>
public sealed class WebRtcVideoPeerSupervisor : IDisposable
{
    // Give helper enough time to fail fast on missing deps/toolchain issues.
    // 300ms is too optimistic on some Windows/Go setups.
    private const int EarlyExitProbeMs = 1500;

    private readonly Options _opt;
    private readonly IWebRtcSignalingService _signaling;
    private readonly HidControl.UseCases.Video.IVideoRuntime _videoRuntime;
    private readonly object _lock = new();
    private readonly Dictionary<string, ProcState> _procs = new(StringComparer.OrdinalIgnoreCase);
    private readonly Dictionary<string, VideoPeerRuntimeState> _runtimeByRoom = new(StringComparer.OrdinalIgnoreCase);
    private readonly Dictionary<string, HashSet<string>> _manualStopsByRoom = new(StringComparer.OrdinalIgnoreCase);
    private readonly Timer _cleanupTimer;

    private sealed record ProcState(Process Process, DateTimeOffset StartedAtUtc, DateTimeOffset? IdleSinceUtc);
    private sealed record VideoPeerRuntimeState(
        string Room,
        string SourceModeRequested,
        string? SourceModeActive,
        bool FallbackUsed,
        string? LastVideoError,
        DateTimeOffset? StartedAtUtc,
        DateTimeOffset UpdatedAtUtc,
        int? Pid,
        bool Running);

    /// <summary>
    /// Snapshot of video peer runtime state for a single room.
    /// </summary>
    public sealed record VideoPeerRuntimeStatus(
        string Room,
        string SourceModeRequested,
        string? SourceModeActive,
        bool FallbackUsed,
        string? LastVideoError,
        DateTimeOffset? StartedAtUtc,
        DateTimeOffset UpdatedAtUtc,
        int? Pid,
        bool Running);

    /// <summary>
    /// Creates an instance.
    /// </summary>
    /// <param name="opt">Server options.</param>
    /// <param name="signaling">Signaling room state service.</param>
    public WebRtcVideoPeerSupervisor(
        Options opt,
        IWebRtcSignalingService signaling,
        HidControl.UseCases.Video.IVideoRuntime videoRuntime)
    {
        _opt = opt;
        _signaling = signaling;
        _videoRuntime = videoRuntime;
        CleanupOrphansFromPidFiles();
        _cleanupTimer = new Timer(_ => CleanupTick(), null, TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(Math.Max(1, _opt.WebRtcRoomsCleanupIntervalSeconds)));
    }

    /// <summary>
    /// Starts the helper if enabled by config.
    /// </summary>
    public void StartIfEnabled()
    {
        if (!_opt.WebRtcVideoPeerAutoStart)
        {
            return;
        }

        string room = string.IsNullOrWhiteSpace(_opt.WebRtcVideoPeerRoom) ? "video" : _opt.WebRtcVideoPeerRoom;
        EnsureStarted(room);
    }

    /// <summary>
    /// Stops all helper processes.
    /// </summary>
    public void Stop()
    {
        string? toolDir = null;
        _ = TryFindToolDir(out toolDir!, out _);
        lock (_lock)
        {
            foreach (var kvp in _procs.ToArray())
            {
                try
                {
                    if (!kvp.Value.Process.HasExited)
                    {
                        kvp.Value.Process.Kill(entireProcessTree: true);
                    }
                }
                catch { }
                finally
                {
                    try { kvp.Value.Process.Dispose(); } catch { }
                    _procs.Remove(kvp.Key);
                    _runtimeByRoom.Remove(kvp.Key);
                    if (!string.IsNullOrWhiteSpace(toolDir))
                    {
                        DeletePidFile(toolDir!, kvp.Key);
                    }
                    ReleaseManualStopsForRoom(kvp.Key);
                }
            }
            ReleaseAllManualStops();
        }
        CleanupOrphansFromPidFiles();
    }

    /// <summary>
    /// Ensures a helper is running for the specified room.
    /// </summary>
    public (bool ok, bool started, int? pid, string? error) EnsureStarted(
        string room,
        string? qualityPreset = null,
        int? bitrateKbps = null,
        int? fps = null)
    {
        if (string.IsNullOrWhiteSpace(room))
        {
            return (false, false, null, "room_required");
        }

        lock (_lock)
        {
            int max = _opt.WebRtcRoomsMaxHelpers;
            if (max > 0 && !_procs.ContainsKey(room) && _procs.Count >= max)
            {
                return (false, false, null, "max_helpers_reached");
            }

            if (_procs.TryGetValue(room, out var existing))
            {
                if (!existing.Process.HasExited)
                {
                    UpsertRuntimeState(room, roomState =>
                    {
                        string requested = NormalizeSourceModeForState(_opt.WebRtcVideoPeerSourceMode);
                        string? active = roomState?.SourceModeActive ?? requested;
                        bool fallback = roomState?.FallbackUsed ?? false;
                        string? lastError = roomState?.LastVideoError;
                        DateTimeOffset startedAt = roomState?.StartedAtUtc ?? existing.StartedAtUtc;
                        return new VideoPeerRuntimeState(
                            room,
                            requested,
                            active,
                            fallback,
                            lastError,
                            startedAt,
                            DateTimeOffset.UtcNow,
                            existing.Process.Id,
                            Running: true);
                    });
                    EnsureCaptureManualStops(room);
                    return (true, false, existing.Process.Id, null);
                }

                try { existing.Process.Dispose(); } catch { }
                _procs.Remove(room);
                MarkRuntimeStopped(room, existing.Process, exitCode: null);
                ReleaseManualStopsForRoom(room);
            }

            if (!TryFindToolDir(out string toolDir, out string toolHint))
            {
                ServerEventLog.Log("webrtc.videopeer", "autostart_skipped", new { reason = "tool_not_found", hint = toolHint });
                return (false, false, null, "tool_not_found");
            }

            if (TryGetRunningPidFromFile(BuildPidFilePath(toolDir, room), out int existingPid))
            {
                EnsureCaptureManualStops(room);
                return (true, false, existingPid, null);
            }

            string serverUrl = BuildLocalServerUrl(_opt.Url);
            string token = _opt.Token ?? string.Empty;

            int? bitrateNorm = NormalizeBitrateKbpsForEnv(bitrateKbps);
            int? fpsNorm = NormalizeFpsForEnv(fps);
            var psi = BuildStartInfo(toolDir, serverUrl, room, token, _opt.WebRtcVideoPeerStun, qualityPreset, bitrateNorm, fpsNorm);
            if (psi is null)
            {
                ServerEventLog.Log("webrtc.videopeer", "autostart_skipped", new { reason = "unsupported_os", os = Environment.OSVersion.Platform.ToString() });
                return (false, false, null, "unsupported_os");
            }
            string pidPath = BuildPidFilePath(toolDir, room);
            psi.Environment["HIDBRIDGE_HELPER_PIDFILE"] = pidPath;

            try
            {
                if (string.Equals(_opt.WebRtcVideoPeerSourceMode, "capture", StringComparison.OrdinalIgnoreCase))
                {
                    EnsureCaptureManualStops(room);
                    // Capture mode competes with legacy ffmpeg/capture workers for the same camera.
                    // Stop them first so dshow/v4l2 can open the device reliably.
                    IReadOnlyList<string> stoppedHelpers = StopTrackedCaptureHelpers(room, toolDir);
                    IReadOnlyList<string> stoppedWorkers = _videoRuntime.StopCaptureWorkersAsync(null, CancellationToken.None).GetAwaiter().GetResult();
                    IReadOnlyList<string> stoppedFfmpeg = _videoRuntime.StopFfmpegProcesses();
                    if (stoppedHelpers.Count > 0 || stoppedWorkers.Count > 0 || stoppedFfmpeg.Count > 0)
                    {
                        ServerEventLog.Log("webrtc.videopeer", "capture_released", new { room, stoppedHelpers, stoppedWorkers, stoppedFfmpeg });
                    }
                }

                var p = new Process { StartInfo = psi, EnableRaisingEvents = true };
                p.Exited += (_, __) =>
                {
                    int code = -1;
                    try { code = p.ExitCode; } catch { }
                    ServerEventLog.Log("webrtc.videopeer", "exit", new { room, code });
                    DeletePidFile(toolDir, room);

                    lock (_lock)
                    {
                        if (_procs.TryGetValue(room, out var st) && ReferenceEquals(st.Process, p))
                        {
                            _procs.Remove(room);
                        }
                        MarkRuntimeStopped(room, p, code);
                        ReleaseManualStopsForRoom(room);
                    }
                };

                if (!p.Start())
                {
                    ServerEventLog.Log("webrtc.videopeer", "autostart_failed", new { room, reason = "start_returned_false" });
                    return (false, false, null, "start_failed");
                }

                // Fail fast if helper exits immediately (missing deps, broken toolchain, bad args).
                if (p.WaitForExit(EarlyExitProbeMs))
                {
                    int code = -1;
                    try { code = p.ExitCode; } catch { }
                    string earlyLogPath = BuildHelperLogPath(toolDir, room);
                    if (code == 0)
                    {
                        // If the shell exits with 0 but helper is still alive (PID file), keep it.
                        if (TryGetRunningPidFromFile(BuildPidFilePath(toolDir, room), out int livePid))
                        {
                            EnsureCaptureManualStops(room);
                            UpsertRuntimeState(room, _ => new VideoPeerRuntimeState(
                                room,
                                NormalizeSourceModeForState(_opt.WebRtcVideoPeerSourceMode),
                                NormalizeSourceModeForState(_opt.WebRtcVideoPeerSourceMode),
                                FallbackUsed: false,
                                LastVideoError: null,
                                StartedAtUtc: DateTimeOffset.UtcNow,
                                UpdatedAtUtc: DateTimeOffset.UtcNow,
                                Pid: livePid,
                                Running: true));
                            ServerEventLog.Log("webrtc.videopeer", "autostart_early_exit_zero", new { room, code, probeMs = EarlyExitProbeMs, pid = livePid, logPath = earlyLogPath });
                            try { p.Dispose(); } catch { }
                            return (true, false, livePid, null);
                        }

                        UpsertRuntimeState(room, _ => new VideoPeerRuntimeState(
                            room,
                            NormalizeSourceModeForState(_opt.WebRtcVideoPeerSourceMode),
                            null,
                            FallbackUsed: false,
                            LastVideoError: "exit_0",
                            StartedAtUtc: null,
                            UpdatedAtUtc: DateTimeOffset.UtcNow,
                            Pid: null,
                            Running: false));
                        ReleaseManualStopsForRoom(room);
                        ServerEventLog.Log("webrtc.videopeer", "autostart_failed", new { room, reason = "exited_early", code, probeMs = EarlyExitProbeMs, logPath = earlyLogPath });
                        try { p.Dispose(); } catch { }
                        return (false, false, null, "exit_0");
                    }

                    UpsertRuntimeState(room, _ => new VideoPeerRuntimeState(
                        room,
                        NormalizeSourceModeForState(_opt.WebRtcVideoPeerSourceMode),
                        null,
                        FallbackUsed: false,
                        LastVideoError: $"exit_{code}",
                        StartedAtUtc: null,
                        UpdatedAtUtc: DateTimeOffset.UtcNow,
                        Pid: null,
                        Running: false));
                    ReleaseManualStopsForRoom(room);
                    ServerEventLog.Log("webrtc.videopeer", "autostart_failed", new { room, reason = "exited_early", code, probeMs = EarlyExitProbeMs, logPath = earlyLogPath });
                    try { p.Dispose(); } catch { }
                    return (false, false, null, $"exit_{code}");
                }

                _procs[room] = new ProcState(p, DateTimeOffset.UtcNow, IdleSinceUtc: null);
                UpsertRuntimeState(room, _ => new VideoPeerRuntimeState(
                    room,
                    NormalizeSourceModeForState(_opt.WebRtcVideoPeerSourceMode),
                    NormalizeSourceModeForState(_opt.WebRtcVideoPeerSourceMode),
                    FallbackUsed: false,
                    LastVideoError: null,
                    StartedAtUtc: DateTimeOffset.UtcNow,
                    UpdatedAtUtc: DateTimeOffset.UtcNow,
                    Pid: p.Id,
                    Running: true));
                string logPath = BuildHelperLogPath(toolDir, room);
                ServerEventLog.Log("webrtc.videopeer", "autostart_started", new
                {
                    serverUrl,
                    room,
                    stun = _opt.WebRtcVideoPeerStun,
                    sourceMode = _opt.WebRtcVideoPeerSourceMode,
                    qualityPreset = NormalizeQualityPresetForEnv(qualityPreset) ?? _opt.WebRtcVideoPeerQualityPreset,
                    bitrateKbps = bitrateNorm,
                    fps = fpsNorm,
                    captureInputSet = !string.IsNullOrWhiteSpace(_opt.WebRtcVideoPeerCaptureInput),
                    ffmpegArgsSet = !string.IsNullOrWhiteSpace(_opt.WebRtcVideoPeerFfmpegArgs),
                    pid = p.Id,
                    exe = psi.FileName,
                    args = psi.Arguments,
                    pidPath,
                    logPath
                });
                return (true, true, p.Id, null);
            }
            catch (Exception ex)
            {
                UpsertRuntimeState(room, _ => new VideoPeerRuntimeState(
                    room,
                    NormalizeSourceModeForState(_opt.WebRtcVideoPeerSourceMode),
                    null,
                    FallbackUsed: false,
                    LastVideoError: ex.Message,
                    StartedAtUtc: null,
                    UpdatedAtUtc: DateTimeOffset.UtcNow,
                    Pid: null,
                    Running: false));
                ReleaseManualStopsForRoom(room);
                ServerEventLog.Log("webrtc.videopeer", "autostart_failed", new { room, error = ex.Message });
                return (false, false, null, ex.Message);
            }
        }
    }

    /// <summary>
    /// Stops a helper process for a specific room.
    /// </summary>
    public (bool ok, bool stopped, string? error) StopRoom(string room)
    {
        if (string.IsNullOrWhiteSpace(room))
        {
            return (false, false, "room_required");
        }

        string toolDir = string.Empty;
        bool hasToolDir = TryFindToolDir(out toolDir, out _);
        bool stoppedByPid = false;
        if (hasToolDir)
        {
            string pidPath = BuildPidFilePath(toolDir, room);
            if (TryGetRunningPidFromFile(pidPath, out int pid) && TryKillByPid(pid))
            {
                stoppedByPid = true;
            }
            DeletePidFile(toolDir, room);
        }

        ProcState? tracked = null;
        bool lockTaken = false;
        try
        {
            if (!Monitor.TryEnter(_lock, TimeSpan.FromSeconds(5)))
            {
                // Avoid long API hangs when helper startup/cleanup currently holds the lock.
                return (true, stoppedByPid, null);
            }
            lockTaken = true;

            if (!_procs.TryGetValue(room, out tracked))
            {
                _runtimeByRoom.Remove(room);
                ReleaseManualStopsForRoom(room);
                return (true, stoppedByPid, null);
            }

            _procs.Remove(room);
            _runtimeByRoom.Remove(room);
            ReleaseManualStopsForRoom(room);
        }
        finally
        {
            if (lockTaken)
            {
                Monitor.Exit(_lock);
            }
        }

        if (tracked is null)
        {
            return (true, stoppedByPid, null);
        }

        bool stoppedTracked = false;
        string? killError = null;
        try
        {
            if (!tracked.Process.HasExited)
            {
                tracked.Process.Kill(entireProcessTree: true);
                stoppedTracked = true;
            }
            else
            {
                stoppedTracked = true;
            }
        }
        catch (Exception ex)
        {
            killError = ex.Message;
        }
        finally
        {
            try { tracked.Process.Dispose(); } catch { }
            if (hasToolDir)
            {
                DeletePidFile(toolDir, room);
            }
        }

        if (!stoppedTracked && !stoppedByPid && !string.IsNullOrWhiteSpace(killError))
        {
            return (false, false, killError);
        }

        return (true, stoppedTracked || stoppedByPid, null);
    }

    /// <summary>
    /// Returns the list of helper rooms currently running.
    /// </summary>
    public IReadOnlyList<object> GetHelpersSnapshot()
    {
        lock (_lock)
        {
            var list = new List<object>(_procs.Count);
            foreach (var kvp in _procs)
            {
                var p = kvp.Value.Process;
                list.Add(new
                {
                    room = kvp.Key,
                    pid = p.HasExited ? (int?)null : p.Id,
                    hasExited = p.HasExited,
                    startedAtUtc = kvp.Value.StartedAtUtc,
                    idleSinceUtc = kvp.Value.IdleSinceUtc
                });
            }
            return list;
        }
    }

    private void CleanupTick()
    {
        int idleStop = _opt.WebRtcRoomIdleStopSeconds;
        if (idleStop <= 0)
        {
            return;
        }
        const int startupGraceSeconds = 20;

        // "video" should be stable; don't auto-stop it.
        var peers = _signaling.GetRoomPeerCountsSnapshot();
        DateTimeOffset now = DateTimeOffset.UtcNow;

        lock (_lock)
        {
            foreach (var room in _procs.Keys.ToArray())
            {
                if (string.Equals(room, "video", StringComparison.OrdinalIgnoreCase))
                {
                    continue;
                }

                if (!_procs.TryGetValue(room, out var st))
                {
                    continue;
                }

                var proc = st.Process;
                if (proc.HasExited)
                {
                    try { proc.Dispose(); } catch { }
                    _procs.Remove(room);
                    MarkRuntimeStopped(room, proc, exitCode: null);
                    ReleaseManualStopsForRoom(room);
                    continue;
                }

                // Give newly started helpers time to complete signaling/join before idle auto-stop kicks in.
                if ((now - st.StartedAtUtc).TotalSeconds < startupGraceSeconds)
                {
                    continue;
                }

                int count = peers.TryGetValue(room, out int c) ? c : 0;
                if (count <= 1)
                {
                    if (st.IdleSinceUtc is null)
                    {
                        _procs[room] = st with { IdleSinceUtc = now };
                        continue;
                    }

                    if ((now - st.IdleSinceUtc.Value).TotalSeconds >= idleStop)
                    {
                        try { proc.Kill(entireProcessTree: true); } catch { }
                        try { proc.Dispose(); } catch { }
                        _procs.Remove(room);
                        MarkRuntimeStopped(room, proc, exitCode: null);
                        ReleaseManualStopsForRoom(room);
                        ServerEventLog.Log("webrtc.videopeer", "autostop_idle", new { room, idleStopSeconds = idleStop });
                    }
                }
                else
                {
                    if (st.IdleSinceUtc is not null)
                    {
                        _procs[room] = st with { IdleSinceUtc = null };
                    }
                }
            }
        }
    }

    private static bool TryFindToolDir(out string toolDir, out string hint)
    {
        string baseDir = AppContext.BaseDirectory;
        string? d = baseDir;
        for (int i = 0; i < 8 && d is not null; i++)
        {
            string candidate = Path.Combine(d, "Tools", "WebRtcVideoPeer");
            if (Directory.Exists(candidate))
            {
                toolDir = candidate;
                hint = candidate;
                return true;
            }
            d = Path.GetDirectoryName(d);
        }
        toolDir = string.Empty;
        hint = $"searched from {baseDir}";
        return false;
    }

    private static string BuildLocalServerUrl(string configuredUrl)
    {
        if (string.IsNullOrWhiteSpace(configuredUrl)) return "http://127.0.0.1:8080";
        // Server itself always runs local; helper must reach it via localhost.
        // Replace host with 127.0.0.1 but keep scheme/port.
        try
        {
            var u = new Uri(configuredUrl);
            var b = new UriBuilder(u) { Host = "127.0.0.1" };
            return b.Uri.ToString().TrimEnd('/');
        }
        catch
        {
            return "http://127.0.0.1:8080";
        }
    }

    private ProcessStartInfo? BuildStartInfo(
        string toolDir,
        string serverUrl,
        string room,
        string token,
        string stun,
        string? qualityPreset,
        int? bitrateKbps,
        int? fps)
    {
        string effectiveQualityPreset = NormalizeQualityPresetForEnv(qualityPreset) ?? _opt.WebRtcVideoPeerQualityPreset;
        if (OperatingSystem.IsWindows())
        {
            string ps1 = Path.Combine(toolDir, "run.ps1");
            if (!File.Exists(ps1))
            {
                return null;
            }

            // Prefer Windows PowerShell; fall back to `powershell` on PATH.
            string shell = File.Exists(Path.Combine(Environment.SystemDirectory, "WindowsPowerShell", "v1.0", "powershell.exe"))
                ? Path.Combine(Environment.SystemDirectory, "WindowsPowerShell", "v1.0", "powershell.exe")
                : "powershell";

            // run.ps1 sets env vars and calls `go run .`.
            string args = $"-NoProfile -ExecutionPolicy Bypass -File \"{ps1}\" -ServerUrl \"{serverUrl}\" -Room \"{room}\" -Token \"{token}\"";
            var psi = new ProcessStartInfo(shell, args)
            {
                UseShellExecute = false,
                CreateNoWindow = true,
                WorkingDirectory = toolDir
            };
            psi.Environment["HIDBRIDGE_STUN"] = stun;
            psi.Environment["HIDBRIDGE_VIDEO_SOURCE_MODE"] = string.IsNullOrWhiteSpace(_opt.WebRtcVideoPeerSourceMode)
                ? "testsrc"
                : _opt.WebRtcVideoPeerSourceMode;
            if (!string.IsNullOrWhiteSpace(_opt.WebRtcVideoPeerCaptureInput))
            {
                psi.Environment["HIDBRIDGE_VIDEO_CAPTURE_INPUT"] = _opt.WebRtcVideoPeerCaptureInput;
            }
            if (!string.IsNullOrWhiteSpace(_opt.WebRtcVideoPeerFfmpegArgs))
            {
                psi.Environment["HIDBRIDGE_VIDEO_FFMPEG_ARGS"] = _opt.WebRtcVideoPeerFfmpegArgs;
            }
            if (!string.IsNullOrWhiteSpace(effectiveQualityPreset))
            {
                psi.Environment["HIDBRIDGE_VIDEO_QUALITY_PRESET"] = effectiveQualityPreset;
            }
            if (bitrateKbps is int b)
            {
                psi.Environment["HIDBRIDGE_VIDEO_BITRATE_KBPS"] = b.ToString();
            }
            if (fps is int f)
            {
                psi.Environment["HIDBRIDGE_VIDEO_FPS"] = f.ToString();
            }
            if (!string.IsNullOrWhiteSpace(_opt.FfmpegPath))
            {
                psi.Environment["HIDBRIDGE_FFMPEG"] = _opt.FfmpegPath;
            }
            return psi;
        }

        if (OperatingSystem.IsLinux() || OperatingSystem.IsMacOS())
        {
            string script = Path.Combine(toolDir, "run.sh");
            if (!File.Exists(script))
            {
                return null;
            }

            // Keep arg order consistent with WebRtcControlPeer: serverUrl, token, room, stun.
            string args = $"\"{script}\" \"{serverUrl}\" \"{token}\" \"{room}\" \"{stun}\"";
            var psi = new ProcessStartInfo("bash", args)
            {
                UseShellExecute = false,
                CreateNoWindow = true,
                WorkingDirectory = toolDir
            };
            psi.Environment["HIDBRIDGE_STUN"] = stun;
            psi.Environment["HIDBRIDGE_VIDEO_SOURCE_MODE"] = string.IsNullOrWhiteSpace(_opt.WebRtcVideoPeerSourceMode)
                ? "testsrc"
                : _opt.WebRtcVideoPeerSourceMode;
            if (!string.IsNullOrWhiteSpace(_opt.WebRtcVideoPeerCaptureInput))
            {
                psi.Environment["HIDBRIDGE_VIDEO_CAPTURE_INPUT"] = _opt.WebRtcVideoPeerCaptureInput;
            }
            if (!string.IsNullOrWhiteSpace(_opt.WebRtcVideoPeerFfmpegArgs))
            {
                psi.Environment["HIDBRIDGE_VIDEO_FFMPEG_ARGS"] = _opt.WebRtcVideoPeerFfmpegArgs;
            }
            if (!string.IsNullOrWhiteSpace(effectiveQualityPreset))
            {
                psi.Environment["HIDBRIDGE_VIDEO_QUALITY_PRESET"] = effectiveQualityPreset;
            }
            if (bitrateKbps is int b)
            {
                psi.Environment["HIDBRIDGE_VIDEO_BITRATE_KBPS"] = b.ToString();
            }
            if (fps is int f)
            {
                psi.Environment["HIDBRIDGE_VIDEO_FPS"] = f.ToString();
            }
            if (!string.IsNullOrWhiteSpace(_opt.FfmpegPath))
            {
                psi.Environment["HIDBRIDGE_FFMPEG"] = _opt.FfmpegPath;
            }
            return psi;
        }

        return null;
    }

    private static string? NormalizeQualityPresetForEnv(string? qualityPreset)
    {
        if (string.IsNullOrWhiteSpace(qualityPreset))
        {
            return null;
        }

        return qualityPreset.Trim().ToLowerInvariant();
    }

    private static int? NormalizeBitrateKbpsForEnv(int? bitrateKbps)
    {
        if (bitrateKbps is null)
        {
            return null;
        }
        if (bitrateKbps < 200 || bitrateKbps > 12000)
        {
            return null;
        }
        return bitrateKbps;
    }

    private static int? NormalizeFpsForEnv(int? fps)
    {
        if (fps is null)
        {
            return null;
        }
        if (fps < 5 || fps > 60)
        {
            return null;
        }
        return fps;
    }

    /// <summary>
    /// Stops other tracked video helpers before starting capture mode to avoid camera lock conflicts.
    /// </summary>
    private IReadOnlyList<string> StopTrackedCaptureHelpers(string roomToKeep, string toolDir)
    {
        var stopped = new List<string>();
        foreach (var kvp in _procs.ToArray())
        {
            string room = kvp.Key;
            if (string.Equals(room, roomToKeep, StringComparison.OrdinalIgnoreCase))
            {
                continue;
            }

            Process p = kvp.Value.Process;
            try
            {
                if (!p.HasExited)
                {
                    p.Kill(entireProcessTree: true);
                }
                stopped.Add(room);
            }
            catch { }
            finally
            {
                try { p.Dispose(); } catch { }
                _procs.Remove(room);
                DeletePidFile(toolDir, room);
                ReleaseManualStopsForRoom(room);
            }
        }

        return stopped;
    }

    /// <summary>
    /// Ensures capture-mode manual-stop flags are set for enabled sources in this room.
    /// </summary>
    private void EnsureCaptureManualStops(string room)
    {
        if (!string.Equals(_opt.WebRtcVideoPeerSourceMode, "capture", StringComparison.OrdinalIgnoreCase))
        {
            return;
        }

        if (!_manualStopsByRoom.TryGetValue(room, out var tracked))
        {
            tracked = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
            _manualStopsByRoom[room] = tracked;
        }

        var newlyTracked = new List<string>();
        foreach (var src in _opt.VideoSources.Where(s => s.Enabled))
        {
            if (string.IsNullOrWhiteSpace(src.Id))
            {
                continue;
            }

            if (tracked.Contains(src.Id))
            {
                continue;
            }

            bool wasManual = _videoRuntime.IsManualStop(src.Id);
            if (!wasManual)
            {
                _videoRuntime.SetManualStop(src.Id, true);
            }

            tracked.Add(src.Id);
            newlyTracked.Add(src.Id);
        }

        if (newlyTracked.Count > 0)
        {
            ServerEventLog.Log("webrtc.videopeer", "capture_manualstop_acquired", new { room, sourceIds = newlyTracked });
        }
    }

    /// <summary>
    /// Releases manual-stop flags previously acquired for a room if no other room still needs them.
    /// </summary>
    private void ReleaseManualStopsForRoom(string room)
    {
        if (!_manualStopsByRoom.TryGetValue(room, out var tracked) || tracked.Count == 0)
        {
            _manualStopsByRoom.Remove(room);
            return;
        }

        _manualStopsByRoom.Remove(room);
        var stillNeeded = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        foreach (var ids in _manualStopsByRoom.Values)
        {
            stillNeeded.UnionWith(ids);
        }

        var released = new List<string>();
        foreach (var id in tracked)
        {
            if (stillNeeded.Contains(id))
            {
                continue;
            }

            _videoRuntime.SetManualStop(id, false);
            released.Add(id);
        }

        if (released.Count > 0)
        {
            ServerEventLog.Log("webrtc.videopeer", "capture_manualstop_released", new { room, sourceIds = released });
        }
    }

    /// <summary>
    /// Releases all manual-stop flags tracked by this supervisor.
    /// </summary>
    private void ReleaseAllManualStops()
    {
        if (_manualStopsByRoom.Count == 0)
        {
            return;
        }

        var release = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        foreach (var ids in _manualStopsByRoom.Values)
        {
            release.UnionWith(ids);
        }
        _manualStopsByRoom.Clear();

        foreach (var id in release)
        {
            _videoRuntime.SetManualStop(id, false);
        }

        if (release.Count > 0)
        {
            ServerEventLog.Log("webrtc.videopeer", "capture_manualstop_released_all", new { sourceIds = release.ToArray() });
        }
    }

    private static string BuildHelperLogPath(string toolDir, string room)
    {
        string safe = new string(room.Select(ch =>
            (char.IsLetterOrDigit(ch) || ch == '-' || ch == '_' || ch == '.') ? ch : '_').ToArray());
        return Path.Combine(toolDir, "logs", $"videopeer_{safe}.log");
    }

    private static string BuildPidFilePath(string toolDir, string room)
    {
        string safe = new string(room.Select(ch =>
            (char.IsLetterOrDigit(ch) || ch == '-' || ch == '_' || ch == '.') ? ch : '_').ToArray());
        return Path.Combine(toolDir, "pids", $"videopeer_{safe}.pid");
    }

    private static bool TryGetRunningPidFromFile(string pidFilePath, out int pid)
    {
        pid = 0;
        try
        {
            if (!File.Exists(pidFilePath))
            {
                return false;
            }

            string raw = File.ReadAllText(pidFilePath).Trim();
            if (!int.TryParse(raw, out pid) || pid <= 0)
            {
                return false;
            }

            Process p = Process.GetProcessById(pid);
            return !p.HasExited;
        }
        catch
        {
            return false;
        }
    }

    private static bool TryKillByPid(int pid)
    {
        try
        {
            Process p = Process.GetProcessById(pid);
            if (!p.HasExited)
            {
                p.Kill(entireProcessTree: true);
            }
            return true;
        }
        catch
        {
            return false;
        }
    }

    /// <summary>
    /// Updates runtime status based on helper-reported signal payload.
    /// </summary>
    /// <param name="room">Room id.</param>
    /// <param name="eventName">Status event name.</param>
    /// <param name="sourceModeActive">Current active source mode.</param>
    /// <param name="detail">Optional detail/error string.</param>
    public void ReportRuntimeStatus(string room, string? eventName, string? sourceModeActive, string? detail)
    {
        if (string.IsNullOrWhiteSpace(room))
        {
            return;
        }

        lock (_lock)
        {
            string eventNorm = string.IsNullOrWhiteSpace(eventName) ? string.Empty : eventName.Trim().ToLowerInvariant();
            string? activeModeNorm = NormalizeSourceModeForStateOrNull(sourceModeActive);
            DateTimeOffset now = DateTimeOffset.UtcNow;

            _runtimeByRoom.TryGetValue(room, out var prev);
            string requested = prev?.SourceModeRequested ?? NormalizeSourceModeForState(_opt.WebRtcVideoPeerSourceMode);
            string? active = activeModeNorm ?? prev?.SourceModeActive ?? requested;
            bool fallback = prev?.FallbackUsed ?? false;
            string? lastError = prev?.LastVideoError;
            DateTimeOffset? startedAt = prev?.StartedAtUtc;
            int? pid = prev?.Pid;
            bool running = prev?.Running ?? _procs.TryGetValue(room, out _);

            if (eventNorm == "fallback")
            {
                fallback = true;
                if (!string.IsNullOrWhiteSpace(detail))
                {
                    lastError = detail;
                }
            }
            else if (eventNorm == "error")
            {
                if (!string.IsNullOrWhiteSpace(detail))
                {
                    lastError = detail;
                }
            }
            else if (eventNorm == "pipeline_started")
            {
                if (startedAt is null)
                {
                    startedAt = now;
                }
            }

            _runtimeByRoom[room] = new VideoPeerRuntimeState(
                room,
                requested,
                active,
                fallback,
                lastError,
                startedAt,
                now,
                pid,
                running);
        }
    }

    /// <summary>
    /// Returns runtime status for a specific room.
    /// </summary>
    /// <param name="room">Room id.</param>
    /// <returns>Runtime status or null when unknown.</returns>
    public VideoPeerRuntimeStatus? GetRoomRuntimeStatus(string room)
    {
        if (string.IsNullOrWhiteSpace(room))
        {
            return null;
        }

        lock (_lock)
        {
            if (_runtimeByRoom.TryGetValue(room, out var st))
            {
                return new VideoPeerRuntimeStatus(
                    st.Room,
                    st.SourceModeRequested,
                    st.SourceModeActive,
                    st.FallbackUsed,
                    st.LastVideoError,
                    st.StartedAtUtc,
                    st.UpdatedAtUtc,
                    st.Pid,
                    st.Running);
            }

            if (_procs.TryGetValue(room, out var procState))
            {
                string requested = NormalizeSourceModeForState(_opt.WebRtcVideoPeerSourceMode);
                int? pid = procState.Process.HasExited ? null : procState.Process.Id;
                bool running = !procState.Process.HasExited;
                return new VideoPeerRuntimeStatus(
                    room,
                    requested,
                    requested,
                    FallbackUsed: false,
                    LastVideoError: null,
                    procState.StartedAtUtc,
                    DateTimeOffset.UtcNow,
                    pid,
                    running);
            }

            return null;
        }
    }

    private static string NormalizeSourceModeForState(string? mode)
    {
        string x = string.IsNullOrWhiteSpace(mode) ? "testsrc" : mode.Trim().ToLowerInvariant();
        return x == "capture" ? "capture" : "testsrc";
    }

    private static string? NormalizeSourceModeForStateOrNull(string? mode)
    {
        if (string.IsNullOrWhiteSpace(mode))
        {
            return null;
        }
        return NormalizeSourceModeForState(mode);
    }

    private void UpsertRuntimeState(string room, Func<VideoPeerRuntimeState?, VideoPeerRuntimeState> build)
    {
        _runtimeByRoom.TryGetValue(room, out var prev);
        _runtimeByRoom[room] = build(prev);
    }

    private void MarkRuntimeStopped(string room, Process process, int? exitCode)
    {
        DateTimeOffset now = DateTimeOffset.UtcNow;
        _runtimeByRoom.TryGetValue(room, out var prev);
        string requested = prev?.SourceModeRequested ?? NormalizeSourceModeForState(_opt.WebRtcVideoPeerSourceMode);
        string? active = prev?.SourceModeActive;
        bool fallback = prev?.FallbackUsed ?? false;
        string? lastError = prev?.LastVideoError;
        if (exitCode is int c && c != 0)
        {
            lastError = $"exit_{c}";
        }

        _runtimeByRoom[room] = new VideoPeerRuntimeState(
            room,
            requested,
            active,
            fallback,
            lastError,
            prev?.StartedAtUtc,
            now,
            Pid: null,
            Running: false);
    }

    private static void DeletePidFile(string toolDir, string room)
    {
        try
        {
            string pidPath = BuildPidFilePath(toolDir, room);
            if (File.Exists(pidPath))
            {
                File.Delete(pidPath);
            }
        }
        catch { }
    }

    /// <summary>
    /// Best-effort orphan cleanup for helper PIDs persisted on disk.
    /// </summary>
    private void CleanupOrphansFromPidFiles()
    {
        if (!TryFindToolDir(out string toolDir, out _))
        {
            return;
        }

        string pidsDir = Path.Combine(toolDir, "pids");
        if (!Directory.Exists(pidsDir))
        {
            return;
        }

        int removedFiles = 0;
        int killed = 0;
        foreach (string file in Directory.EnumerateFiles(pidsDir, "videopeer_*.pid"))
        {
            try
            {
                string raw = File.ReadAllText(file).Trim();
                if (int.TryParse(raw, out int pid) && pid > 0 && TryKillByPid(pid))
                {
                    killed++;
                }
            }
            catch { }
            finally
            {
                try
                {
                    File.Delete(file);
                    removedFiles++;
                }
                catch { }
            }
        }

        int killedByName = KillLegacyByProcessNames("webrtcvideopeer", "WebRtcVideoPeer");
        if (removedFiles > 0 || killed > 0 || killedByName > 0)
        {
            ServerEventLog.Log("webrtc.videopeer", "orphan_cleanup", new { removedFiles, killed, killedByName });
        }
    }

    private static int KillLegacyByProcessNames(params string[] names)
    {
        int killed = 0;
        foreach (string name in names)
        {
            Process[] procs;
            try
            {
                procs = Process.GetProcessesByName(name);
            }
            catch
            {
                continue;
            }

            foreach (Process p in procs)
            {
                try
                {
                    if (p.HasExited)
                    {
                        continue;
                    }

                    p.Kill(entireProcessTree: true);
                    killed++;
                }
                catch { }
                finally
                {
                    try { p.Dispose(); } catch { }
                }
            }
        }

        return killed;
    }

    /// <inheritdoc />
    public void Dispose()
    {
        _cleanupTimer.Dispose();
        Stop();
    }
}
